# elazar/phantestic

A small PHP testing framework that aims to be simple, fast, modern, and flexible.

Currently in a very alpha state. Feel free to mess around with it, but expect things to break.

## Installation

Use [Composer](https://getcomposer.org).

```json
{
    "require-dev": {
        "elazar/phantestic": "^0.1"
    }
}
```

## Components

A **test loader** loads the test to be run. It can be anything that implements [`\Traversable`](http://php.net/manual/en/class.traversable.php) (i.e. an instance of a class that implements [`\Iterator`](http://php.net/manual/en/class.iterator.php) or [`\IteratorAggregate`](http://php.net/manual/en/class.iteratoraggregate.php), such as [`Generator`](http://php.net/manual/en/class.generator.php)) to allow the loaded tests to be iterable.

The **test runner** uses the test loader to load tests, run them, and in the process emit multiple events that **handlers** can intercept and act upon.

As an example, [`LocalTestRunner`](https://github.com/elazar/phantestic/blob/master/src/TestRunner/LocalTestRunner.php) runs tests in the same PHP process as the test runner. Its constructor accepts two arguments: the test loader to use and an array of handler objects that implement [`TestHandlerInterface`](https://github.com/elazar/phantestic/blob/master/src/TestHandler/TestHandlerInterface.php).

When its `run()` method is called, [`LocalTestRunner`](https://github.com/elazar/phantestic/blob/master/src/TestRunner/LocalTestRunner.php) handles injecting an [event emitter](https://github.com/igorw/evenement/blob/master/src/Evenement/EventEmitterInterface.php) into the handler objects. At that point, those objects can register callbacks with the emitter for any events that may be relevant to them.

An example of a handler is [`CliReporter`](https://github.com/elazar/phantestic/blob/master/src/TestHandler/CliReporter.php), which outputs the results of tests to `stdout` as they are received and a failure summary once all tests have been run.

## Configuring a Runner

Here's a sample runner configuration.

```php
$classmap_path = __DIR__ . '/../vendor/composer/autoload_classmap.php';
$loader = new \Phantestic\TestLoader\ClassmapObjectTestLoader($classmap_path);
$handlers = [ new \Phantestic\TestHandler\CliReporter ];
$runner = new \Phantestic\TestRunner\LocalTestRunner($loader, $handlers);
$runner->run();
```

[`ClassmapObjectTestLoader`](https://github.com/elazar/phantestic/blob/master/src/TestLoader/ClassmapObjectTestLoader.php) locates tests based on a classmap, such as the one generated by [Composer](htts://getcomposer.org). By default, it looks for class files with names ending in `Test.php`, instantiates the classes, and invokes methods with names prefixed with `test`. The regular expressions used to match file and method names are configurable via the constructor of [`ClassmapObjectTestLoader`](https://github.com/elazar/phantestic/blob/master/src/TestLoader/ClassmapObjectTestLoader.php).

## Writing Tests

Theoretically, tests can be anything [callable](http://php.net/manual/en/language.types.callable.php). The test loader may restrict this to specific types of callables (e.g. [`ClassmapObjectTestLoader`](https://github.com/elazar/phantestic/blob/master/src/TestLoader/ClassmapObjectTestLoader.php) only supports instance methods). The test loader wraps test callbacks in an instance of a class implementing [`TestCaseInterface`](https://github.com/elazar/phantestic/blob/master/src/TestCase/TestCaseInterface.php), such as the default [`TestCase`](https://github.com/elazar/phantestic/blob/master/src/TestCase/TestCase.php) implementation.

Failures can be indicated by throwing an [exception](http://php.net/manual/en/language.exceptions.php). Other statuses can be indicating by throwing an instance of a subclass of [`TestResult`](https://github.com/elazar/phantestic/blob/master/src/TestResult/TestResult.php). [`TestCase`](https://github.com/elazar/phantestic/blob/master/src/TestCase/TestCase.php) [converts errors to exceptions](http://php.net/manual/en/class.errorexception.php#errorexception.examples) and considers any uncaught exception to indicate failure. Likewise, no exception being thrown indicates success.

```php
// src/Adder.php
class Adder
{
    public function add($x, $y)
    {
        return $x + $y;
    }
}

// tests/AdderTest.php
class AdderTest
{
    public function testAdd()
    {
        $adder = new Adder;
        $result = $adder->add(2, 2);
        if ($result != 4) {
            throw new \RangeException('2 + 2 should equal 4');
        }
    }
}
```
